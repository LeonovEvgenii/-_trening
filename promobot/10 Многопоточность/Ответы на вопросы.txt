1) Как создать новый поток в C++ с использованием стандартной библиотеки?

Подключаем заголовок
#include <thread>

Создаем функцию, которая содержит логику работы потока.
Создаем экземпляр std::thread и передаем ему в конструктор функцию с логикой потока.
Проверяем переменную joinable и ждем завершения потока.
В случае с методом join() в блокирующем режиме.


2) Что такое std::thread::join() и std::thread::detach() и в чем их различия?

join блокирует родительский поток. Флаг joinable не сбрасывется.

detach позволяет потоку выполняться отдельно от родительского.
joinable сбрасывается. Нельзя вызывать join после вызова detach.


3) Как работают мьютексы (std::mutex) и зачем они нужны?

Мьютексы позволяют блокировать доступ к общим ресурсам.
Подключаются заголовком
#include <mutex>

Создается экземпляр класса std::mutex

Ресурс блокируется от других потоков вызовом методоа lock() у объекта std::mutex.
Потом возмозны операции с ресурсом.
Потом ресурс необходмио освободить методом unlock().

Возможн автоматический контроль за разблокировкой мьютекса использованием

std::lock_guard<std::mutex> lock(mutex_name);

При неиспользловании мьютексов порядок доступа к ресурсам будет в не тривиальном порядке.


4) Что такое состояние гонки (race condition) и как его избежать?

Тип ошибки, когда при использовании общих ресурсов несколькими потоками
получается непредсказуемый результат из-за изменения данных в общем ресурсе
и отсутсвия блокировок.

Избегается применением механизмов синхронизации.
Например мьютексы, атомарные переменные.
Можно так же по возможности избегать общих ресурсов между потоками.


5) Как использовать условные переменные (std::condition_variable) для синхронизации потоков?

Подключить заголовок
#include <condition_vaiable>

создать экземпляр класса std::condition_variable

Использовать методы condition_variable для синхорнизации потоков.

метод wait блокирует выполнение до достижения условия переданного в метод.
метод notify_one уведомляет один ожидающий поток



