Группа 2

animals.cpp

    //Q// давай изменим код так, что бы здесь не было переменных типа Dog, Cat
    // а был только Animal, при этом в логе я хочу видеть гав - гав и мяу мяу

    Не вижу вариантов как вызывать методы make_sound без калссов Dog и Cat.

    Можно создать указатели на Animal, но при их создании все равно придется использовать Dog и Cat.

circle.cpp

    //Q// я понимаю что Rush! и заданий очень много, но  класс наверно называется Circle =)

    Класс переименован, т к пользовался переименованием через f2 в vs code, 
    а имя совпало в нескольких файлах.

figure.cpp

    //Q// что означает virtual float area() = 0;
    // как изменится код задачи при этом? Какой смысл будет у Figure?

    virtual float area() = 0;

    virtual - означет, что функцию можно переопределить. Еще другой тип связывания.
     = 0; - функция становится чистой. Класс абстрактным.

    При указании функции абстрактной, пришлось бы убрать ее реализацию.

student.cpp

    //Q// сколько копирований будет при передачи std::string таким образом - как это оптимизировать?
    // почему данный способ оптимизации не подходит для инт и флоат? 

    При передаче по значению типа std::string производится одно копирование.
    Передаваемый параметр копируется в область памяти, с которым будет работать функция.
    
    Можно пердать параметр по ссылке, тогда копирования не будет, но при этом 
    будет возможно изменение передаваемого параметра внутри функции.

    Передавать значения по ссылке можно любого тип и инт и флоат.

    Данные типы просты, поэтому копированеи будет не сложным.

    //Q// что будет, если public поменять на другие модификаторы доступа?
    // какие изменения в коде нужно сделать, чтобы задача была выполнена? 

    При наследованнии все наследуемые поля и меотоды становятся такими, какой модификатор доступа
     указан при наследовании.

    Для этого перед именем наследуемого класа указать нужный модификатор доступа вместо public.

Ответы на вопросы.txt

    //Q// - это полностью неверно, сюда добавлю еще вопрос - чем отличается класс от структуры? 

    В структурах все члены публичны.
    В классе по умолчанию все члены приватные.

    Структуры используются для более простых задач.

    //Q// кто вызывает конструктор и деструктор?

    Компилятор в автоматическом режиме или поргаммист принудительно.

    //Q// что такое принцип RAII  - в чем его смысл - приведи пример классов STL реализованных по этому принципу

    Принцип RAII - в констркторе размещать занимание ресурса, в деструкторе - освобождение.
    Пример - std:lock_guard. В конструкторе блокируется переданный мьютекс. При окончании блока
    мьютекс освобождается в деструкторе.

Группа 4

    //Q// точки останова существуют и как инструкции в объектных файлах - что это за инструкции? 
    (не только в ИДЕ)
    // как работает точка ост с т.з. процессора?

    В объектном файле добавляются инструкции прерывания и инструкции сбора информации.
    При достиженнии места с точкой останова генерируется исключение.

    С точки зрения процессора программа доходит до определенной инструкции.
    Отлаживаемый процесс приостонавливается, управление получает отладчик.
    Отладчик считывает текущие значения регистров и ячеек памяти.
    Отладчик может восстановить оригнальную инструкцтию, либо завершить
    программу, либо выполнить другие команды для отладки.
    По команде возобновляется выполнение  отлаживаемой программы.

    //Q// что такое компиляция? что такое компановка(линковка)? 

    Компиляция - перобразование исходного кода в файл машинного кода,
    назваемого так же объектным файлом. Предварительно может бытьосуществлена
    проверка синтаксиса.

    Компановка - объединение объектных файлов в единиый исполнямый файл.

2_segmentation_fault.c

    //Q// это нормальный практика цикла? как его можно прервать при условии неизменности строчки while(1)

    Даный цикл приводит к определенному классу ошибок.
    Цикл может не остановиться.

    Прервать можно инструкцией 
    
    break;

2_corrected.c

    //Q// когда маллок может вернуть NULL? почему нет проверки?

    NULL может вернуться, если не удалось выделить запрошенное количество памяти.

    //Q// чем отличается i++ от ++i с т.з. количества операций? почему?

    i++ сначала используется, потом инкрементируется.
    Для инкремента приходится хранить копию значения до использования.
    
    ++i сначала используется, потом инкрементируется.
    Нет необходимости сохранять значение, т к пред использованием
    оно уже должно быть инкрементированно.

    //Q//где выделяется память этой переменной? какой объем?

    Память будет выделена в стеке, т к объявление происходит внутри функции (в частности в main).
    Объем будет вычеслен автоматически (количество_сиволов * количество_байт_на_символ).

    //Q// что будет если запустишь программу несколько раз?

    При каждом запуске будет выводиться строка "Hello from losst"

    